#!/usr/bin/env python3
"""
SetFactionIsPlayer_EDSM.py — Detects player factions via EDSM and writes incremental SQL.

What it does
------------
- For each faction name (input file):
  * Searches EDSM and opens the ID-based faction page
  * Parses "Player faction: Yes/No"
  * APPENDS per-faction output immediately (resume-friendly)
    - If Yes: writes UPDATE setting IsPlayer = 1
    - If No : writes a NONPLAYER note (and, if --set-nonplayer, writes UPDATE IsPlayer = 0)
    - If not found/timeout: writes MISS with reason
- Supports --retry-misses to reprocess only previously missed entries
- Adds BEGIN TRAN on first write, and COMMIT at the end (unless --no-commit)

Usage
-----
python SetFactionIsPlayer_EDSM.py factions.txt -o update_isplayer.sql
python SetFactionIsPlayer_EDSM.py factions.txt -o update_isplayer.sql --set-nonplayer
python SetFactionIsPlayer_EDSM.py factions.txt -o update_isplayer.sql --retry-misses
"""

import sys
import os
import re
import time
import html
import logging
from datetime import datetime
from pathlib import Path
from typing import Iterable, Optional, Tuple, List, Set
from urllib.parse import quote_plus, urljoin

import requests
from bs4 import BeautifulSoup
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

BASE = "https://www.edsm.net"
SEARCH_URL = f"{BASE}/en/search/factions/index/name/{{q}}"

HEADERS = {
    "User-Agent": "SetFactionIsPlayer_EDSM/1.0 (+FalconsFactionMonitor | polite fetcher)",
    "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
    "Accept-Language": "en-US,en;q=0.9",
    "Connection": "keep-alive",
}

# --- Sessions -------------------------------------------------------------------
search_session = requests.Session()
search_session.headers.update(HEADERS)
search_retry = Retry(
    total=4, connect=2, read=2,
    backoff_factor=1.2,
    status_forcelist=(429, 500, 502, 503, 504),
    allowed_methods=("GET",),
    raise_on_status=False,
)
search_session.mount("https://", HTTPAdapter(max_retries=search_retry))
search_session.mount("http://", HTTPAdapter(max_retries=search_retry))

details_session = requests.Session()
details_session.headers.update(HEADERS)
# No internal read retries: we’ll handle timing with our own loop/hard deadline.
details_session.mount("https://", HTTPAdapter(max_retries=Retry(total=0)))
details_session.mount("http://", HTTPAdapter(max_retries=Retry(total=0)))

# --- Helpers --------------------------------------------------------------------
def _norm(s: str) -> str:
    return re.sub(r"\s+", " ", s or "").strip().lower()

def escape_sql_literal(value: str) -> str:
    return value.replace("'", "''")

def read_faction_names(path: Path) -> List[str]:
    return [ln.strip() for ln in path.read_text(encoding="utf-8").splitlines() if ln.strip()]

def append_lines(out_path: Path, lines: Iterable[str]) -> None:
    out_path.parent.mkdir(parents=True, exist_ok=True)
    with open(out_path, "a", encoding="utf-8", newline="\n") as f:
        for line in lines:
            f.write(line + "\n")
        f.flush()
        os.fsync(f.fileno())

HEADER_LINE = "-- Generated by SetFactionIsPlayer_EDSM.py (EDSM-based player flag)"

def ensure_header(out_path: Path) -> None:
    if not out_path.exists() or out_path.stat().st_size == 0:
        append_lines(out_path, [
            HEADER_LINE,
            f"-- Started: {datetime.now().isoformat(timespec='seconds')}",
            "BEGIN TRAN;",
            "",
            "-- Incremental output; safe to resume. Checks 'Player faction' on EDSM.",
            "",
        ])

def has_commit(out_path: Path) -> bool:
    if not out_path.exists():
        return False
    try:
        return "COMMIT;" in out_path.read_text(encoding="utf-8", errors="ignore")
    except Exception:
        return False

def load_processed_names(out_path: Path, names: List[str]) -> Set[str]:
    """
    Consider processed if we already wrote:
      - UPDATE ... WHERE f.FactionName = '<name>';
      - or a NONPLAYER line;
      - or a MISS/RETRY MISS line.
    """
    done: Set[str] = set()
    if not out_path.exists():
        return done
    txt = out_path.read_text(encoding="utf-8", errors="ignore")
    for n in names:
        esc = escape_sql_literal(n)
        where_sig = f"WHERE f.FactionName = '{esc}';"
        if where_sig in txt:
            done.add(n); continue
        if f"-- NONPLAYER: {n}" in txt:
            done.add(n); continue
        if f"-- MISS: {n}" in txt or f"-- RETRY MISS: {n}" in txt:
            done.add(n)
    return done

def load_miss_names(out_path: Path, names: List[str]) -> Set[str]:
    misses: Set[str] = set()
    if not out_path.exists():
        return misses
    name_set = set(names)
    for line in out_path.read_text(encoding="utf-8", errors="ignore").splitlines():
        s = line.strip()
        if s.startswith("-- MISS: ") or s.startswith("-- RETRY MISS: "):
            raw = s.split(": ", 1)[1]
            name_only = raw
            idx = raw.rfind(" (")
            if idx != -1 and raw.endswith(")"):
                name_only = raw[:idx]
            cand = name_only.strip()
            if cand in name_set:
                misses.add(cand)
    return misses

# --- EDSM scraping --------------------------------------------------------------
def search_edsm_faction_url(name: str, timeout: float = 25.0) -> Optional[str]:
    q = quote_plus(name)
    url = SEARCH_URL.format(q=q)
    r = search_session.get(url, timeout=timeout)
    if r.status_code != 200:
        return None

    soup = BeautifulSoup(r.text, "html.parser")
    candidates: List[Tuple[str, str]] = []
    for a in soup.select("a[href]"):
        href = a.get("href", "")
        if re.search(r"/en/faction/id/\d+/name/", href):
            full = href if href.startswith("http") else urljoin(BASE, href)
            txt = a.get_text(strip=True) or ""
            candidates.append((txt, full))

    if not candidates:
        return None

    target = _norm(name)
    for txt, full in candidates:
        if _norm(txt) == target:
            return full
    return candidates[0][1]

def fetch_details_html(details_url: str, timeout: float = 75.0) -> Optional[str]:
    r = details_session.get(details_url, timeout=timeout)
    if r.status_code == 404:
        return None
    r.raise_for_status()
    return r.text

def parse_player_flag(html_text: str) -> Optional[bool]:
    """
    Returns True if 'Player faction: Yes', False if '... No', or None if not present.
    Much more robust: first scan the full page text, then try structural fallbacks.
    """
    soup = BeautifulSoup(html_text, "html.parser")

    # 1) Fast path: regex over full text (handles inline "Player faction: Yes")
    full = soup.get_text(" ", strip=True)
    m = re.search(r"(Player\s*Faction|Player\s*faction)\s*:\s*(Yes|No)", full, re.IGNORECASE)
    if m:
        return m.group(2).strip().lower().startswith("y")

    # 2) Structural fallbacks: look for a label-ish node, then its neighbor
    label_re = re.compile(r"^\s*Player\s*faction\s*:?\s*$", re.IGNORECASE)

    # a) <dt>Player faction</dt><dd>Yes</dd>
    for dt in soup.find_all("dt", string=label_re):
        dd = dt.find_next("dd")
        if dd:
            val = dd.get_text(strip=True).lower()
            if val.startswith("yes"): return True
            if val.startswith("no"):  return False

    # b) <th>Player faction</th><td>Yes</td>  or  <td>Player faction</td><td>Yes</td>
    for th in soup.find_all(["th", "td"], string=label_re):
        nxt = th.find_next("td")
        if nxt:
            val = nxt.get_text(strip=True).lower()
            if val.startswith("yes"): return True
            if val.startswith("no"):  return False

    # c) Generic: any element whose text is exactly the label; inspect nearby text/anchor
    for el in soup.find_all(string=label_re):
        # next anchor
        a = el.parent.find_next("a")
        if a and a.get_text(strip=True):
            v = a.get_text(strip=True).lower()
            if v.startswith("yes"): return True
            if v.startswith("no"):  return False
        # sibling text
        sib = el.parent.next_sibling
        if sib:
            v = (sib.get_text(strip=True) if hasattr(sib, "get_text") else str(sib)).strip().lower()
            if v.startswith("yes"): return True
            if v.startswith("no"):  return False

    return None

def fetch_player_flag(
    faction_name: str,
    search_timeout: float = 25.0,
    details_timeout: float = 75.0,
    max_retries: int = 3,
    hard_deadline_secs: float = 150.0,
) -> Tuple[Optional[bool], Optional[str]]:
    """
    Returns (is_player, miss_reason). miss_reason is None on success.
    """
    start = time.monotonic()

    details_url = search_edsm_faction_url(faction_name, timeout=search_timeout)
    if not details_url:
        return None, "not found (search)"

    last_exc = None
    for attempt in range(1, max_retries + 1):
        if time.monotonic() - start > hard_deadline_secs:
            return None, "timeout"
        try:
            html_text = fetch_details_html(details_url, timeout=details_timeout)
            if not html_text:
                return None, "details 404"
            flag = parse_player_flag(html_text)
            if flag is True or flag is False:
                return flag, None
            return None, "no 'Player faction' field"
        except requests.exceptions.ReadTimeout:
            last_exc = "read-timeout"
        except Exception as e:
            last_exc = str(e)
        time.sleep(1.2 * attempt)

    reason = "timeout" if last_exc == "read-timeout" else f"error: {last_exc}"
    return None, reason

# --- SQL emit -------------------------------------------------------------------
def make_update_isplayer(faction_name: str, value: int) -> str:
    f = escape_sql_literal(faction_name)
    return (
        "UPDATE f\n"
        f"SET f.IsPlayer = {value}\n"
        "FROM ref.Faction AS f\n"
        f"WHERE f.FactionName = '{f}';"
    )

# --- Main -----------------------------------------------------------------------
def main(argv: List[str]) -> int:
    import argparse

    parser = argparse.ArgumentParser(
        description="Detect player factions using EDSM ('Player faction: Yes/No'). Writes incremental SQL and supports --retry-misses."
    )
    parser.add_argument("input", help="UTF-8 text file of faction names (one per line).")
    parser.add_argument("-o", "--output", default="update_isplayer.sql",
                        help="Output .sql file (appended incrementally).")
    parser.add_argument("--sleep", type=float, default=1.0,
                        help="Delay between factions in seconds (default: 1.0).")
    parser.add_argument("--search-timeout", type=float, default=25.0)
    parser.add_argument("--details-timeout", type=float, default=75.0)
    parser.add_argument("--retries", type=int, default=3,
                        help="Max outer retries for details page.")
    parser.add_argument("--hard-timeout", type=float, default=150.0,
                        help="Hard per-faction deadline in seconds.")
    parser.add_argument("--no-commit", dest="no_commit", action="store_true",
                        help="Do not auto-append COMMIT even if all names are processed.")
    parser.add_argument("--retry-misses", action="store_true",
                        help="Only retry factions previously marked as MISS in the output SQL.")
    parser.add_argument("--set-nonplayer", action="store_true",
                        help="Also write UPDATE IsPlayer = 0 when 'Player faction: No' is detected.")
    args = parser.parse_args(argv[1:])

    logging.basicConfig(level=logging.INFO, format="%(levelname)s: %(message)s")

    names = read_faction_names(Path(args.input))
    if not names:
        logging.error("No faction names found in %s", args.input)
        return 2

    out_path = Path(args.output)
    ensure_header(out_path)

    if args.retry_misses:
        prior_misses = load_miss_names(out_path, names)
        if not prior_misses:
            logging.info("No prior MISS entries found in %s. Nothing to retry.", out_path)
            return 0
        # Skip any that already got an UPDATE later
        already = load_processed_names(out_path, list(prior_misses))
        to_process = [n for n in names if n in prior_misses and n not in already]
        total = len(to_process)
        done = 0
        logging.info("Retrying %d previously missed factions (EDSM player flag)…", total)
    else:
        already = load_processed_names(out_path, names)
        to_process = [n for n in names if n not in already]
        total = len(names)
        done = len(already)
        logging.info("Looking up 'Player faction' on EDSM for %d factions…", total)
        if already:
            logging.info("Resuming: %d/%d already present in output.", done, total)

    updates_this_run = 0
    misses_this_run = 0

    for name in to_process:
        logging.info("… %s → (searching %d/%d)", name, (done + 1 if not args.retry_misses else done + 1), (total if not args.retry_misses else total))

        is_player, miss_reason = fetch_player_flag(
            name,
            search_timeout=args.search_timeout,
            details_timeout=args.details_timeout,
            max_retries=args.retries,
            hard_deadline_secs=args.hard_timeout,
        )

        if is_player is True:
            logging.info("✔ %s → Player faction: Yes", name)
            block = [
                f"-- UPDATE IsPlayer for faction: {name} (Player=Yes)",
                make_update_isplayer(name, 1),
                "",
            ]
            append_lines(out_path, block)
            updates_this_run += 1

        elif is_player is False:
            logging.info("✔ %s → Player faction: No", name)
            if args.set_nonplayer:
                block = [
                    f"-- UPDATE IsPlayer for faction: {name} (Player=No)",
                    make_update_isplayer(name, 0),
                    "",
                ]
                append_lines(out_path, block)
                updates_this_run += 1
            else:
                append_lines(out_path, [f"-- NONPLAYER: {name} (Player=No)", ""])
            # Count as processed either way

        else:
            reason = f"{miss_reason}" if miss_reason else "unknown"
            logging.info("✖ %s → (not found) (%s)", name, reason)
            append_lines(out_path, [f"-- {'RETRY MISS' if args.retry_misses else 'MISS'}: {name} ({reason})", ""])
            misses_this_run += 1

        done += 1
        time.sleep(args.sleep)

    if not args.retry_misses:
        if done == total and not has_commit(out_path) and not args.no_commit:
            append_lines(out_path, ["-- Completed: " + datetime.now().isoformat(timespec="seconds"), "COMMIT;", ""])

    logging.info("Run complete. Appended %d updates, %d misses.", updates_this_run, misses_this_run)
    return 0

if __name__ == "__main__":
    raise SystemExit(main(sys.argv))
