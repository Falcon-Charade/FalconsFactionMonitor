#!/usr/bin/env python3
"""
SetFactionIsPlayer_Inara.py — Detect player factions via INARA and write incremental SQL.

What it does
------------
- For each faction name (input file):
  * Searches INARA and opens the minor-faction page
  * Parses "Player minor faction: Yes/No" (or "Player faction: Yes/No")
  * APPENDS per-faction output immediately (resume-friendly)
    - If Yes: writes UPDATE setting IsPlayer = 1
    - If No : writes a NONPLAYER note (and, if --set-nonplayer, writes UPDATE IsPlayer = 0)
    - If not found/timeout: writes MISS with reason
- Supports --retry-misses to reprocess only previously missed entries
- Adds BEGIN TRAN on first write, and COMMIT at the end (unless --no-commit)

Usage
-----
python SetFactionIsPlayer_Inara.py factions.txt -o update_isplayer_inara.sql
python SetFactionIsPlayer_Inara.py factions.txt -o update_isplayer_inara.sql --set-nonplayer
python SetFactionIsPlayer_Inara.py factions.txt -o update_isplayer_inara.sql --retry-misses
"""

import sys
import os
import re
import time
import html
import logging
from datetime import datetime
from pathlib import Path
from typing import Iterable, Optional, Tuple, List, Set
from urllib.parse import quote_plus, urljoin

import requests
from bs4 import BeautifulSoup
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

BASE = "https://inara.cz"
SEARCH_URL = f"{BASE}/elite/minorfaction/?search={{q}}"

HEADERS = {
    "User-Agent": "SetFactionIsPlayer_Inara/1.0 (+FalconsFactionMonitor | polite fetcher)",
    "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
    "Accept-Language": "en-US,en;q=0.9",
    "Connection": "keep-alive",
}

# Sessions -----------------------------------------------------------------------
search_session = requests.Session()
search_session.headers.update(HEADERS)
search_retry = Retry(
    total=3, connect=2, read=2,
    backoff_factor=1.2,
    status_forcelist=(429, 500, 502, 503, 504),
    allowed_methods=("GET",),
    raise_on_status=False,
)
search_session.mount("https://", HTTPAdapter(max_retries=search_retry))
search_session.mount("http://", HTTPAdapter(max_retries=search_retry))

details_session = requests.Session()
details_session.headers.update(HEADERS)
# no internal read retries; we control timing with outer loop + hard deadline
details_session.mount("https://", HTTPAdapter(max_retries=Retry(total=0)))
details_session.mount("http://", HTTPAdapter(max_retries=Retry(total=0)))

# Helpers ------------------------------------------------------------------------
def _norm(s: str) -> str:
    return re.sub(r"\s+", " ", s or "").strip().lower()

def escape_sql_literal(value: str) -> str:
    return value.replace("'", "''")

def read_faction_names(path: Path) -> List[str]:
    return [ln.strip() for ln in path.read_text(encoding="utf-8").splitlines() if ln.strip()]

def append_lines(out_path: Path, lines: Iterable[str]) -> None:
    out_path.parent.mkdir(parents=True, exist_ok=True)
    with open(out_path, "a", encoding="utf-8", newline="\n") as f:
        for line in lines:
            f.write(line + "\n")
        f.flush()
        os.fsync(f.fileno())

HEADER_LINE = "-- Generated by SetFactionIsPlayer_Inara.py (INARA-based player flag)"

def ensure_header(out_path: Path) -> None:
    if not out_path.exists() or out_path.stat().st_size == 0:
        append_lines(out_path, [
            HEADER_LINE,
            f"-- Started: {datetime.now().isoformat(timespec='seconds')}",
            "BEGIN TRAN;",
            "",
            "-- Incremental output; safe to resume. Checks 'Player minor faction'/'Player faction' on INARA.",
            "",
        ])

def has_commit(out_path: Path) -> bool:
    if not out_path.exists():
        return False
    try:
        return "COMMIT;" in out_path.read_text(encoding="utf-8", errors="ignore")
    except Exception:
        return False

def load_processed_names(out_path: Path, names: List[str]) -> Set[str]:
    """
    Consider processed if we already wrote:
      - UPDATE ... WHERE f.FactionName = '<name>';
      - or a NONPLAYER line;
      - or a MISS/RETRY MISS line.
    """
    done: Set[str] = set()
    if not out_path.exists():
        return done
    txt = out_path.read_text(encoding="utf-8", errors="ignore")
    for n in names:
        esc = escape_sql_literal(n)
        where_sig = f"WHERE f.FactionName = '{esc}';"
        if where_sig in txt:
            done.add(n); continue
        if f"-- NONPLAYER: {n}" in txt:
            done.add(n); continue
        if f"-- MISS: {n}" in txt or f"-- RETRY MISS: {n}" in txt:
            done.add(n)
    return done

def load_miss_names(out_path: Path, names: List[str]) -> Set[str]:
    misses: Set[str] = set()
    if not out_path.exists():
        return misses
    name_set = set(names)
    for line in out_path.read_text(encoding="utf-8", errors="ignore").splitlines():
        s = line.strip()
        if s.startswith("-- MISS: ") or s.startswith("-- RETRY MISS: "):
            raw = s.split(": ", 1)[1]
            name_only = raw
            idx = raw.rfind(" (")
            if idx != -1 and raw.endswith(")"):
                name_only = raw[:idx]
            cand = name_only.strip()
            if cand in name_set:
                misses.add(cand)
    return misses

# INARA scraping -----------------------------------------------------------------
def search_inara_faction_url(name: str, timeout: float = 25.0) -> Optional[str]:
    """
    Returns absolute URL to the faction page (/elite/minorfaction/<id>/) or None.
    """
    q = quote_plus(name)
    url = SEARCH_URL.format(q=q)
    r = search_session.get(url, timeout=timeout)
    if r.status_code != 200:
        return None

    soup = BeautifulSoup(r.text, "html.parser")
    candidates: List[Tuple[str, str]] = []
    for a in soup.select("a[href]"):
        href = a.get("href", "")
        # match minor faction detail links (e.g., /elite/minorfaction/12345/)
        if re.search(r"/elite/minorfaction/\d+/?", href):
            full = href if href.startswith("http") else urljoin(BASE, href)
            txt = a.get_text(strip=True) or ""
            candidates.append((txt, full))

    if not candidates:
        return None

    target = _norm(name)
    for txt, full in candidates:
        if _norm(txt) == target:
            return full
    return candidates[0][1]

def fetch_details_html(details_url: str, timeout: float = 60.0) -> Optional[str]:
    r = details_session.get(details_url, timeout=timeout)
    if r.status_code == 404:
        return None
    r.raise_for_status()
    return r.text

def parse_player_flag_inara(html_text: str) -> Optional[bool]:
    """
    Returns True if 'Player minor faction: Yes' / 'Player faction: Yes',
    False if '... No', or None if not present.
    Strategy:
      1) Regex over full text to catch inline 'Label: Yes'
      2) Structured fallbacks for table/dl layouts
    """
    soup = BeautifulSoup(html_text, "html.parser")

    # 1) Full text scan (robust against inline formats)
    full = soup.get_text(" ", strip=True)
    m = re.search(r"(Player\s*(minor)?\s*faction)\s*:\s*(Yes|No)", full, re.IGNORECASE)
    if m:
        return m.group(3).strip().lower().startswith("y")

    # 2) Structured fallbacks
    label_re = re.compile(r"^\s*Player\s*(minor)?\s*faction\s*:?\s*$", re.IGNORECASE)

    # a) <dt>Player minor faction</dt><dd>Yes</dd>
    for dt in soup.find_all("dt", string=label_re):
        dd = dt.find_next("dd")
        if dd:
            val = dd.get_text(strip=True).lower()
            if val.startswith("yes"): return True
            if val.startswith("no"):  return False

    # b) <th>Player minor faction</th><td>Yes</td> or <td>Player minor faction</td><td>Yes</td>
    for th in soup.find_all(["th", "td"], string=label_re):
        nxt = th.find_next("td")
        if nxt:
            val = nxt.get_text(strip=True).lower()
            if val.startswith("yes"): return True
            if val.startswith("no"):  return False

    # c) Generic: any node matching the label; check nearby anchor/text
    for el in soup.find_all(string=label_re):
        a = el.parent.find_next("a")
        if a and a.get_text(strip=True):
            v = a.get_text(strip=True).lower()
            if v.startswith("yes"): return True
            if v.startswith("no"):  return False
        sib = el.parent.next_sibling
        if sib:
            v = (sib.get_text(strip=True) if hasattr(sib, "get_text") else str(sib)).strip().lower()
            if v.startswith("yes"): return True
            if v.startswith("no"):  return False

    return None

def fetch_player_flag_inara(
    faction_name: str,
    search_timeout: float = 25.0,
    details_timeout: float = 60.0,
    max_retries: int = 3,
    hard_deadline_secs: float = 120.0,
) -> Tuple[Optional[bool], Optional[str]]:
    """
    Returns (is_player, miss_reason). miss_reason is None on success.
    """
    start = time.monotonic()

    details_url = search_inara_faction_url(faction_name, timeout=search_timeout)
    if not details_url:
        return None, "not found (search)"

    last_exc = None
    for attempt in range(1, max_retries + 1):
        if time.monotonic() - start > hard_deadline_secs:
            return None, "timeout"
        try:
            html_text = fetch_details_html(details_url, timeout=details_timeout)
            if not html_text:
                return None, "details 404"
            flag = parse_player_flag_inara(html_text)
            if flag is True or flag is False:
                return flag, None
            return None, "no 'Player faction' field"
        except requests.exceptions.ReadTimeout:
            last_exc = "read-timeout"
        except Exception as e:
            last_exc = str(e)
        time.sleep(1.1 * attempt)

    reason = "timeout" if last_exc == "read-timeout" else f"error: {last_exc}"
    return None, reason

# SQL emit -----------------------------------------------------------------------
def make_update_isplayer(faction_name: str, value: int) -> str:
    f = escape_sql_literal(faction_name)
    return (
        "UPDATE f\n"
        f"SET f.IsPlayer = {value}\n"
        "FROM ref.Faction AS f\n"
        f"WHERE f.FactionName = '{f}';"
    )

# Main ---------------------------------------------------------------------------
def main(argv: List[str]) -> int:
    import argparse

    parser = argparse.ArgumentParser(
        description="Detect player factions using INARA ('Player minor faction'/'Player faction'). Writes incremental SQL and supports --retry-misses."
    )
    parser.add_argument("input", help="UTF-8 text file of faction names (one per line).")
    parser.add_argument("-o", "--output", default="update_isplayer_inara.sql",
                        help="Output .sql file (appended incrementally).")
    parser.add_argument("--sleep", type=float, default=2.0,  # 2 seconds per your preference
                        help="Delay between factions in seconds (default: 2.0).")
    parser.add_argument("--search-timeout", type=float, default=25.0)
    parser.add_argument("--details-timeout", type=float, default=60.0)
    parser.add_argument("--retries", type=int, default=3,
                        help="Max outer retries for details page.")
    parser.add_argument("--hard-timeout", type=float, default=120.0,
                        help="Hard per-faction deadline in seconds.")
    parser.add_argument("--no-commit", dest="no_commit", action="store_true",
                        help="Do not auto-append COMMIT even if all names are processed.")
    parser.add_argument("--retry-misses", action="store_true",
                        help="Only retry factions previously marked as MISS in the output SQL.")
    parser.add_argument("--set-nonplayer", action="store_true",
                        help="Also write UPDATE IsPlayer = 0 when 'Player faction: No' is detected.")
    args = parser.parse_args(argv[1:])

    logging.basicConfig(level=logging.INFO, format="%(levelname)s: %(message)s")

    names = read_faction_names(Path(args.input))
    if not names:
        logging.error("No faction names found in %s", args.input)
        return 2

    out_path = Path(args.output)
    ensure_header(out_path)

    if args.retry_misses:
        prior_misses = load_miss_names(out_path, names)
        if not prior_misses:
            logging.info("No prior MISS entries found in %s. Nothing to retry.", out_path)
            return 0
        already = load_processed_names(out_path, list(prior_misses))
        to_process = [n for n in names if n in prior_misses and n not in already]
        total = len(to_process)
        done = 0
        logging.info("Retrying %d previously missed factions (INARA player flag)…", total)
    else:
        already = load_processed_names(out_path, names)
        to_process = [n for n in names if n not in already]
        total = len(names)
        done = len(already)
        logging.info("Looking up 'Player faction' on INARA for %d factions…", total)
        if already:
            logging.info("Resuming: %d/%d already present in output.", done, total)

    updates_this_run = 0
    misses_this_run = 0

    for name in to_process:
        logging.info("… %s → (searching %d/%d)", name, (done + 1 if not args.retry_misses else done + 1), (total if not args.retry_misses else total))

        is_player, miss_reason = fetch_player_flag_inara(
            name,
            search_timeout=args.search_timeout,
            details_timeout=args.details_timeout,
            max_retries=args.retries,
            hard_deadline_secs=args.hard_timeout,
        )

        if is_player is True:
            logging.info("✔ %s → Player faction: Yes (INARA)", name)
            block = [
                f"-- UPDATE IsPlayer for faction: {name} (Player=Yes, INARA)",
                make_update_isplayer(name, 1),
                "",
            ]
            append_lines(out_path, block)
            updates_this_run += 1

        elif is_player is False:
            logging.info("✔ %s → Player faction: No (INARA)", name)
            if args.set_nonplayer:
                block = [
                    f"-- UPDATE IsPlayer for faction: {name} (Player=No, INARA)",
                    make_update_isplayer(name, 0),
                    "",
                ]
                append_lines(out_path, block)
                updates_this_run += 1
            else:
                append_lines(out_path, [f"-- NONPLAYER: {name} (Player=No, INARA)", ""])

        else:
            reason = f"{miss_reason}" if miss_reason else "unknown"
            logging.info("✖ %s → (not found) (%s)", name, reason)
            append_lines(out_path, [f"-- {'RETRY MISS' if args.retry_misses else 'MISS'}: {name} ({reason})", ""])
            misses_this_run += 1

        done += 1
        time.sleep(args.sleep)  # default 2s between factions

    if not args.retry_misses:
        if done == total and not has_commit(out_path) and not args.no_commit:
            append_lines(out_path, ["-- Completed: " + datetime.now().isoformat(timespec="seconds"), "COMMIT;", ""])

    logging.info("Run complete. Appended %d updates, %d misses.", updates_this_run, misses_this_run)
    return 0

if __name__ == "__main__":
    raise SystemExit(main(sys.argv))
